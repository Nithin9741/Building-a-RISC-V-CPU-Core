CPUs come in many flavors, from small microcontrollers, optimized for small area and low power, to desktop and server processors, optimized for performance. Within several hours,you will construct a CPU core
that could be appropriate as a microcontroller.In contrast, a desktop or server CPU chip might be built by a team of hundreds of seasoned engineers over a period of several years.
Our CPU will fully execute one instruction with each new clock cycle. Doing all of this work within a single clock cycle is only possible if the clock is running relatively slowly, which is our assumption.
We will start by implementing enough of the CPU to execute our test program. As you add each new piece of functionality, you will see in the VIZ pane the behavior you implemented,
with more and more of the test program executing correctly until it is successfully summing numbers from one to nine. Then we will go back to implement support for the bulk of the RV32I instruction set.
Letâ€™s look at the components of our CPU, following the flow of an instruction through the logic. This is also roughly the order in which we will implement the logic.

![image](https://github.com/Nithin9741/Building-a-RISC-V-CPU-Core/assets/101901668/b5f0b737-1dd9-4b9f-b94a-19aef0386436)

